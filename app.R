# Load necessary libraries
library(shiny)
library(ggplot2)
library(dplyr)
library(tidyr)
library(plotly)
library(shinythemes)
library(readr)
library(forcats)
library(scales)

# Define preferred range values
lipari_ranges <- data.frame(
  Element = c("SiO2", "TiO2", "Al2O3", "FeO", "MnO", "MgO", "CaO", "Na2O", "K2O", "P2O5"),
  Lower = c(72.8200, 0.0400, 11.7800, 1.1200, 0.0300, 0.0000, 0.5800, 3.2700, 4.7100, 0.0000),
  Upper = c(75.6600, 0.1200, 14.0600, 1.8800, 0.1100, 0.0800, 0.9000, 4.7500, 5.5500, 0.0300)
)

bcr2g_ranges <- data.frame(
  Element = c("SiO2", "TiO2", "Al2O3", "FeO", "MnO", "MgO", "CaO", "Na2O", "K2O", "P2O5"),
  Lower = c(53.6, 2.19, 12.6, 11.8, 0.17, 3.38, 6.84, 3.09, 1.66, 0.35),
  Upper = c(55.2, 2.35, 14.2, 13, 0.21, 3.74, 7.28, 3.37, 1.82, 0.39)
)

# Define a custom theme
Tephra.theme <- theme_bw() +
  theme(
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    axis.text.x = element_text(size = 16),
    axis.text.y = element_text(size = 16),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

# Define UI
ui <- fluidPage(
  theme = shinytheme("yeti"),
  titlePanel(
    div(
      img(src = "logo.png", class = "logo-image"),
      "AshplotR Standards", windowTitle = "AshplotR Standards",
      style = "display: flex; align-items: center; justify-content: space-between;"
    )
  ),
  
  sidebarLayout(
    sidebarPanel(
      h4("1. Select your standard"),
      selectInput("ranges", "Preferred Ranges File:", choices = c("Lipari", "BCR-2G"), selected = "Lipari"),
      br(),
      
      h4("2. Upload your data"),
      fileInput("file", "2. Upload a CSV file of your standard data"),
      br(),
      
      h4("3. Select Element to Plot Over Time"),
      selectInput("selected_element", "Element:", 
                  choices = c("SiO2", "TiO2", "Al2O3", "FeO", "MnO", "MgO", "CaO", "Na2O", "K2O", "P2O5"), 
                  selected = "FeO"),
      br(),
      h4("Download Plots"),
      downloadButton("downloadallPlot", "Download all data Plot"),
      downloadButton("downloadTimePlot", "Download One Element vs. Time Plot"),
      downloadButton("downloadTimeAllPlot", "Download All Elements vs. Time Plot"),
      
      div(
        HTML("<div style='margin-top: 20px;'>
               <p>This shiny app has been created in order to assess the precision and accuracy of secondary standard data used in EPMA analysis. It has been tested using data generated by the author at TAU in the University of Edinburgh. Therefore it is set up to analyse the secondary standards and elements routinely analysed at this unit. At present, it permits the assessment of user-generated secondary standard data for the Lipari Obsidian and BCR-2G against preferred values given for these standards. The preferred values of the Lipari Obsidian are those of:
               Hayward, C. (2012). High spatial resolution electron probe microanalysis of tephras and melt inclusions without beam-induced chemical modification. The Holocene, 22(1), 119-125. 
               <a href='https://doi.org/10.1177/0959683611409777' target='_blank'>https://doi.org/10.1177/0959683611409777</a>
               while the preferred values for BCR-2G are those provided by GEOREM which can be found at: 
               <a href='http://georem.mpch-mainz.gwdg.de/sample_query_pref.asp' target='_blank'>GEOREM BCR-2G preferred values</a>.
               </p>
             </div>"),
        HTML("<div style='margin-top: 20px;'>
              <p>The citation is: Matthews, Ian; Pike, Joshua (2023). AshplotR. Royal Holloway, University of London. Software. 
              <a href='https://doi.org/10.17637/rh.21941432.v1' target='_blank'>https://doi.org/10.17637/rh.21941432.v1</a>.</p>
             </div>"),
      ),
      HTML("<div style='margin-top: 20px;'>
              <p>This is part of the AshplotR suite of web apps. Once data standard checks have been made you may wish to plot your unknown tephra layers using the original AshplotR app found at: 
              <a href='https://ian-matthews.shinyapps.io/AshplotR-shiny/' target='_blank'>https://ian-matthews.shinyapps.io/AshplotR-shiny/</a>.</p>
             </div>"),
      
      absolutePanel(
        bottom = "2px", left = "10px",
        style = "font-size: 14px; font-style: italic; color: #666;",
        "App Author: Ian Matthews"
      )
    ),
    
    mainPanel(
      navbarPage(
        "Selection",
        id = "plotTabs",  # Adding an ID to track which tab is selected
        tabPanel("Summary Table",
                 tabPanel("Summary Table", tableOutput("summary")),
        ),
        navbarMenu("Explore Data",
                   tabPanel("Plot", plotlyOutput("plot", height = "800px", width = "1000px")),
                   tabPanel("Element Over Time", plotlyOutput("time_plot", height = "800px", width = "1000px")),
                   tabPanel("All Elements Over Time", plotlyOutput("time_all_plot", height = "800px", width = "1000px"))
        )
      )
    )
  ),
  # Add custom CSS for the logo image
  tags$head(
    tags$style(HTML("
      .logo-image {
        max-width: 60px;
        max-height: 60px;
      }
    "))
  )
)



# Define server logic
server <- function(input, output) {
  
  # Reactive values for data
  data <- reactiveValues()
  
  # Reactive expression for selected ranges
  selected_ranges <- reactive({
    if (input$ranges == "Lipari") {
      return(lipari_ranges)
    } else {
      return(bcr2g_ranges)
    }
  })
  
  observeEvent(input$file, {
    req(input$file)
    data$file <- read.csv(input$file$datapath)
    
    # Ensure date_time is parsed properly
    data$file$date_time <- as.POSIXct(data$file$date_time, format="%d/%m/%Y %H:%M")
    
    # Process the data to the long format and merge with selected ranges
    data$long <- data$file %>%
      pivot_longer(cols = -c(Total, date_time), names_to = "Element", values_to = "Value") %>%
      left_join(selected_ranges(), by = "Element") %>%
      mutate(
        OutsideRange = ifelse(Value < Lower | Value > Upper, "Outside", "Within"),
        Element = fct_relevel(Element, lipari_ranges$Element), # Reorder elements
        Element = fct_rev(Element)  # Reverse order to descending
      )
  })
  
  element_order <- c("SiO2", "TiO2", "Al2O3", "FeO", "MnO", "MgO", "CaO", "Na2O", "K2O", "P2O5", "Total")
  element_labels <- setNames(element_order, element_order)  # Create named labeller for consistent order
  
  
  # Render main plot
  output$plot <- renderPlotly({
    req(data$long)
    gg <- ggplot(data$long) +
      geom_segment(aes(x = Lower, xend = Upper, y = Element, yend = Element), color = "gray", size = 10, alpha = 0.8) +
      geom_point(aes(x = (Lower + Upper) / 2, y = Element), shape = 1, size = 4) +
      geom_jitter(aes(x = Value, y = reorder(Element, desc(Element)), color = OutsideRange, shape = OutsideRange),
                  width = 0, height = 0.25, alpha = 0.3, size = 4) +
      labs(title = "Standard Data Compared with Preferred Values", 
           x = "wt %", y = "Oxide", 
           color = NULL,
           subtitle = "Preferred ranges are given as the grey bar and the mean average given as the open circle") +
      scale_color_manual(values = c("Within" = "steelblue3", "Outside" = "red")) +
      scale_shape_manual(values = c("Within" = 19, "Outside" = 13)) +
      theme(legend.position = "left") +
      guides(color = guide_legend(title = "Range"), 
             shape = guide_legend(title = "Range")) +  # Combine legends
      Tephra.theme
    
    ggplotly(gg, width = 1000, height = 800, res = 300) %>%
      config(toImageButtonOptions = list(format = "png", width = 1000, height = 800, scale = 2))

  })
  
  output$summary <- renderUI({
    req(data$file)
    
    # Calculate summary statistics
    summary_stats <- data$file %>%
      pivot_longer(-c(Total, date_time), names_to = "Element", values_to = "Value") %>%
      group_by(Element) %>%
      summarise(
        mean = mean(Value, na.rm = TRUE), 
        sd = sd(Value, na.rm = TRUE), 
        preferred_lower = first(selected_ranges()$Lower[selected_ranges()$Element == Element]),
        preferred_upper = first(selected_ranges()$Upper[selected_ranges()$Element == Element])
      )
    
    # Order the elements based on selected ranges
    summary_stats <- summary_stats[order(match(summary_stats$Element, selected_ranges()$Element)), ]
    
    # Number of datapoints and date range for analysis (based on the data file)
    n_points <- nrow(data$file)
    start_date <- min(data$file$date_time, na.rm = TRUE)
    end_date <- max(data$file$date_time, na.rm = TRUE)
    
    # Format date range for display
    analysis_date <- if (as.Date(start_date) == as.Date(end_date)) {
      format(start_date, "%d %B %Y")  # Single date
    } else {
      paste(format(start_date, "%d %B %Y"), "to", format(end_date, "%d %B %Y"))  # Date range
    }
    
    # Render the table with additional information
    tagList(
      # Title and metadata
      h3(paste("Summary Statistics of Uploaded", input$ranges, "Data")),
      p(strong("Number of Data Points:"), n_points),
      p(strong("Date Range of Analysis:"), analysis_date),
      br(),
      
      # Summary table
      renderTable(summary_stats, rownames = FALSE, striped = TRUE, hover = TRUE, bordered = TRUE, align = "c")
    )
  })
  
  
  
  # Reactive expression for long data used in time-series plots
  data_long_2 <- reactive({
    req(data$file)
    data$file %>%
      pivot_longer(cols = -c(Total, date_time), names_to = "Element", values_to = "Value") %>%
      left_join(selected_ranges(), by = "Element") %>%
      mutate(
        date_time_parsed = as.POSIXct(date_time, format="%d/%m/%Y %H:%M")
      )
  })
  
  output$time_plot <- renderPlotly({
    req(data_long_2())
    data_long <- data_long_2()
    selected_element <- input$selected_element
    
    # Get limits for selected element
    limits <- selected_ranges() %>% filter(Element == selected_element)
    req(nrow(limits) == 1)
    
    # Filter data for the selected element
    element_data <- data_long %>%
      filter(Element == selected_element) %>%
      mutate(
        RangeStatus = ifelse(Value < limits$Lower | Value > limits$Upper, "Outside", "Within")  # Add range status column
      )
    
    # Calculate date range for title
    start_date <- min(element_data$date_time_parsed, na.rm = TRUE)
    end_date <- max(element_data$date_time_parsed, na.rm = TRUE)
    
    title_date <- if (as.Date(start_date) == as.Date(end_date)) {
      format(start_date, "%d %B %Y")  # Single date
    } else {
      paste(format(start_date, "%d %B %Y"), "to", format(end_date, "%d %B %Y"))  # Date range
    }
    
    y_range <- max(element_data$Value, na.rm = TRUE) - min(element_data$Value, na.rm = TRUE)
    offset <- 0.04 * y_range  # Set the offset as 4% of the y-axis range
    
    # Create ggplot for the selected element with color and symbol mapped by RangeStatus
    gg_time <- ggplot(element_data, aes(x = date_time_parsed, y = Value, color = RangeStatus, shape = RangeStatus)) +
      geom_point(size = 3, alpha = 0.8) +
      geom_hline(yintercept = limits$Lower, linetype = "dashed", color = "red") +
      geom_hline(yintercept = limits$Upper, linetype = "dashed", color = "red") +
      annotate("text", x = start_date, y = limits$Lower - offset, label = "Lower", color = "red", vjust = 1, hjust = 0) +
      annotate("text", x = start_date, y = limits$Upper + offset, label = "Upper", color = "red", vjust = -1, hjust = 0) +
      labs(title = paste(selected_element, "Levels Over Time Compared to Preferred Range\n", title_date),
           x = "Time", y = paste(selected_element, "(wt %)")) +
      scale_color_manual(values = c("Within" = "steelblue3", "Outside" = "red")) +  # Color mapping
      scale_shape_manual(values = c("Within" = 19, "Outside" = 13)) +  # Shape mapping
      Tephra.theme +
      theme(plot.margin = margin(10, 10, 10, 10))
    
    ggplotly(gg_time, width = 1000, height = 800, res = 300) %>%
      layout(xaxis = list(title = "Date and Time"), yaxis = list(title = paste(selected_element, "(wt %)"))) %>%
      config(toImageButtonOptions = list(format = "png", width = 1000, height = 800, scale = 2))
  })
  
  
  output$time_all_plot <- renderPlotly({
    req(data$long)
    
    # Calculate the range of dates in your dataset
    start_date <- min(as.POSIXct(data$long$date_time, format="%d/%m/%Y %H:%M"))
    end_date <- max(as.POSIXct(data$long$date_time, format="%d/%m/%Y %H:%M"))
    
    # Format the title based on the number of unique days
    title_date <- if (as.Date(start_date) == as.Date(end_date)) {
      format(start_date, "%d %B %Y")  # Single date
    } else {
      paste(format(start_date, "%d %B %Y"), "to", format(end_date, "%d %B %Y"))  # Date range
    }
    
    # Time-series plot for all elements with preferred range annotations
    gg_time_all <- ggplot(data$long, aes(x = date_time, y = Value, color = OutsideRange, shape = OutsideRange)) +
      geom_point(size = 2, alpha = 0.6) +
      geom_hline(aes(yintercept = Lower), data = selected_ranges(), linetype = "dashed", color = "red") +
      geom_hline(aes(yintercept = Upper), data = selected_ranges(), linetype = "dashed", color = "red") +
      facet_grid(Element ~ ., scales = "free_y", switch = "y", labeller = as_labeller(element_labels)) +
      labs(title = paste("Standard values Over Time Compared to Preferred Ranges\n", title_date), 
           x = "Date and Time", y = "(wt %)", subtitle = "Dashed lines show upper and lower limits") +
      scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
      scale_color_manual(values = c("Within" = "steelblue3", "Outside" = "red")) +
      scale_shape_manual(values = c("Within" = 19, "Outside" = 13)) +  # Customize shape (e.g., filled circle for "Within", open circle for "Outside")
      Tephra.theme +
      theme(
        strip.placement = "outside",
        strip.text.y.left = element_text(angle = 0),  # Horizontal labels for the facet strip
        axis.title.x = element_text(size = 10),
        axis.ticks.x = element_blank(),
        plot.margin = margin(5, 5, 5, 5),
        panel.spacing.y = unit(0.15, "lines"),  # Adjust spacing to improve visibility
        axis.title.y = element_text(size = 10),
        axis.text.y = element_text(size = 8),
        strip.background = element_blank()
      )
    
    ggplotly(gg_time_all) %>%
      config(toImageButtonOptions = list(format = "png", width = 1000, height = 800, scale = 2))
  })
  
  output$downloadallPlot <- downloadHandler(
    filename = function() { "allplot.pdf" },
    content = function(file) {
      pdf(file, width = 10, height = 10)
      gg <- ggplot(data$long) +
        geom_segment(aes(x = Lower, xend = Upper, y = Element, yend = Element), color = "gray", size = 10, alpha = 0.8) +
        geom_point(aes(x = (Lower + Upper) / 2, y = Element), shape = 1, size = 4) +
        geom_jitter(aes(x = Value, y = reorder(Element, desc(Element)), color = OutsideRange, shape = OutsideRange),
                    width = 0, height = 0.25, alpha = 0.3, size = 4) +
        labs(title = "Standard Data Compared with Preferred Values", 
             x = "wt %", y = "Oxide", 
             color = NULL,
             subtitle = "Preferred ranges are given as the grey bar and the mean average given as the open circle") +
        scale_color_manual(values = c("Within" = "steelblue3", "Outside" = "red")) +
        scale_shape_manual(values = c("Within" = 19, "Outside" = 13)) +
        theme(legend.position = "left") +
        guides(color = guide_legend(title = "Range"), 
               shape = guide_legend(title = "Range")) +
        Tephra.theme
      print(gg)
      dev.off()
    }
  )
  
  output$downloadTimePlot <- downloadHandler(
    filename = function() { paste(input$selected_element, "timeplot.pdf", sep = "_") },
    content = function(file) {
      pdf(file, width = 10, height = 10)
      
      # Filter data and set limits for the selected element
      element_data <- data_long_2() %>% filter(Element == input$selected_element)
      limits <- selected_ranges() %>% filter(Element == input$selected_element)
      req(nrow(limits) == 1)
      
      # Add RangeStatus to indicate if values are within or outside the range
      element_data <- element_data %>%
        mutate(RangeStatus = ifelse(Value < limits$Lower | Value > limits$Upper, "Outside", "Within"))
      
      # Date range for title
      start_date <- min(element_data$date_time_parsed, na.rm = TRUE)
      end_date <- max(element_data$date_time_parsed, na.rm = TRUE)
      title_date <- if (as.Date(start_date) == as.Date(end_date)) {
        format(start_date, "%d %B %Y")
      } else {
        paste(format(start_date, "%d %B %Y"), "to", format(end_date, "%d %B %Y"))
      }
      
      # Plot with range annotations
      gg_time <- ggplot(element_data, aes(x = date_time_parsed, y = Value, color = RangeStatus, shape = RangeStatus)) +
        geom_point(size = 3, alpha = 0.8) +
        geom_hline(yintercept = limits$Lower, linetype = "dashed", color = "red") +
        geom_hline(yintercept = limits$Upper, linetype = "dashed", color = "red") +
        labs(title = paste(input$selected_element, "Levels Over Time Compared to Preferred Range\n", title_date),
             x = "Time", y = paste(input$selected_element, "(wt %)")) +
        scale_color_manual(values = c("Within" = "steelblue3", "Outside" = "red")) +
        scale_shape_manual(values = c("Within" = 19, "Outside" = 13)) +
        Tephra.theme
      
      print(gg_time)
      dev.off()
    }
  )
  
  
  output$downloadTimeAllPlot <- downloadHandler(
    filename = function() {
      paste("time_all_plot_", input$ranges, ".pdf", sep = "")
    },
    content = function(file) {
      # Ensure that title_date is calculated within the content function
      req(data$long)
      
      # Calculate the range of dates in your dataset
      start_date <- min(as.POSIXct(data$long$date_time, format="%d/%m/%Y %H:%M"))
      end_date <- max(as.POSIXct(data$long$date_time, format="%d/%m/%Y %H:%M"))
      
      # Format the title based on the number of unique days
      title_date <- if (as.Date(start_date) == as.Date(end_date)) {
        format(start_date, "%d %B %Y")  # Single date
      } else {
        paste(format(start_date, "%d %B %Y"), "to", format(end_date, "%d %B %Y"))  # Date range
      }
      
      # Now create the plot with the correct title_date
      pdf(file, width = 10, height = 12)
      
      gg_time_all_static <- ggplot(data$long, aes(x = date_time, y = Value, color = OutsideRange, shape = OutsideRange)) +
        geom_point(size = 2, alpha = 0.6) +
        geom_hline(aes(yintercept = Lower), data = selected_ranges(), linetype = "dashed", color = "red") +
        geom_hline(aes(yintercept = Upper), data = selected_ranges(), linetype = "dashed", color = "red") +
        facet_grid(Element ~ ., scales = "free_y", switch = "y", labeller = as_labeller(element_labels)) +
        labs(title = paste("Standard values Over Time Compared to Preferred Ranges\n", title_date), 
             x = "Date and Time", y = "(wt %)", subtitle = "Dashed lines show upper and lower limits") +
        scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
        scale_color_manual(values = c("Within" = "steelblue3", "Outside" = "red")) +
        scale_shape_manual(values = c("Within" = 19, "Outside" = 13)) +  
        Tephra.theme +
        theme(
          strip.placement = "outside",
          strip.text.y = element_text(angle = 0, size = 8, hjust = 1),  # Move facet labels to the right
          strip.text.y.left = element_text(angle = 90, size = 8, hjust = 0),  # Rotate to the right
          axis.title.x = element_text(size = 10),
          axis.ticks.x = element_blank(),
          plot.margin = margin(5, 5, 5, 5),
          panel.spacing.y = unit(0.15, "lines"),  # Adjust spacing for clarity
          axis.title.y = element_text(size = 10),
          axis.text.y = element_text(size = 8),
          strip.background = element_blank(),
          legend.position = "bottom",  # Place legend at the bottom
          legend.title = element_blank(),  # Remove legend title
          legend.key.size = unit(1, "lines"),  # Adjust the size of legend keys
          legend.direction = "horizontal",  # Make legend horizontal
          legend.box = "horizontal"  # Align legend in a horizontal box
        )
      
      print(gg_time_all_static)
      dev.off()
    }
  )
  
  
  
  
  
  
  
}

# Run the application
shinyApp(ui = ui, server = server)

